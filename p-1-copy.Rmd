---
title: "Assignment 1"
date: "2025-04-12"
output:  html_document
---

```{r setup, include=FALSE}
library(dslabs)
library(dplyr)
library(ggplot2)
library(tidyverse)
library(data.table)
library(caTools)
library(histogram)
ds_theme_set()

#install.packages("rmarkdown")

#install.packages("knitr"


library(plm)

library(knitr)

knitr::opts_chunk$set(echo = TRUE)
```




# Question 1:

## (a)

The function below, takes two inputs as required and constructs an OLS estimator. It first concatenates
a vectors of 1s along with the input X since this function is written for a regression with intercept. Secondly, it verifies the compatibility of dimensions to avoid errors. Lastly, it computes the required
transpose matrix and inversion exercise to apply OLS formula. The output returned is a set of coefficients including the intercept and other coefficients.



```{r 1a}


ols_estimate <- function(y, X) {
  X <- cbind(1, X)  # Add intercept
  if (nrow(X) != length(y)) {
    stop("The number of rows in X must match the length of y")
  }
  beta_hat <- solve(t(X) %*% X) %*% t(X) %*% y
  return(as.vector(beta_hat))  # Return coefficients as vector
}


```


## (b)

The code below verifies that the output from lm() function coincides with the output produced by
my coefficients. In both cases, the values of the three coefficients including an intercept and
two controls are the same.


```{r 1b}


# Define the parameters
beta = matrix(c(3, 3, 3), nrow = 3, ncol = 1)
# Define the X matrix
X = matrix(data = rnorm(200), nrow = 100, ncol = 2)
# Define the disurbance
u = rnorm(100)
# Create a column of ones
ones = matrix(1, nrow = 100, ncol = 1)
# Define the y matrix
y = cbind(ones, X) %*% beta + u
# Run lm
test_lm = lm(y ~ X)
summary(test_lm)
# TODO Now run your function

coefficients <- ols_estimate(y, X)
print(coefficients)

```

## Question 2 (a):

In this part, I just use the code provided and apply my OLS estimate function to sample generated by
the sample_df() function. I construct the X matrix by using cbind() first before passing it as an
input to ols_estimate() function which will also by default, estimate the model with an intercept, leading to total of four variables.


```{r 2a}


# Set a seed
set.seed(12)
# Set the number of observations desired
n = 100
# Generate the population (starting with the "unobserved" disturbances)
sample_df = tibble(
  id = 1:n,
  u = rnorm(n),
  v = rnorm(n),
  w = rnorm(n),
  epsilon = v + w,
  x1 = rnorm(n),
  x2 = rnorm(n),
  x3 = u + w,
  y = 0 + 1 * x1 + 2 * x2 + 3 * x3 + epsilon
  
)

X = cbind(sample_df$x1, sample_df$x2, sample_df$x3)



# Now run your function
R = ols_estimate(y, X)



```











